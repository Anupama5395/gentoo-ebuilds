#!/sbin/runscript
# Copyright 1999-2011 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header: /var/cvsroot/gentoo-x86/sys-fs/mdadm/files/mdraid.rc,v 1.6 2011/11/12 21:06:44 vapier Exp $

depend() {
	before checkfs fsck
	after modules
}

start() {
	local mdadm_conf mdmod_conf mods devs mod dev timeout device node rc output

	mdadm_conf="/etc/mdadm/mdadm.conf"
	mdmod_conf="/etc/mdadm/mdmod.conf"
	[ -e /etc/mdadm.conf -a ! -e "$mdadm_conf" ] && mdadm_conf="/etc/mdadm.conf"
	[ -e /etc/mdmod.conf -a ! -e "$mdmod_conf" ] && mdmod_conf="/etc/mdmod.conf"

	if [ -x /sbin/mdadm -a -f "${mdadm_conf}" ]; then
		mods="$( awk '/^[[:space:]]*MODULE/ { print $2 }' "${mdadm_conf}" )"
		devs="$( awk '/^[[:space:]]*ARRAY/ { print $2 }' "${mdadm_conf}" )"

		if [ -n "${mods}" ]; then
			for mod in ${mods}; do
				mod="$( echo "${mod}" | sed 's/-/_/g' )"

				if [ -z "$( lsmod | grep "${mod}" )" ]; then
					ebegin "Loading RAID driver ${mod}"
					modprobe "${mod}"
					eend $? "Module load failed - storage array may be unavailable" || continue
				fi

				dev=$( egrep "^[[:space:]]*MODULE" "${mdmod_conf}" | \
					tr -s "[:space:]" | sed 's/^ //' | cut -d" " -f 3-
				)

				#
				# We can't wait until all devices are present, as some of the
				# physical disks they represent may be unplugged...
				#
				timeout=50

				while test ${timeout} -gt 0 ; do
					for device in ${dev}; do
						[ -e "${device}" ] && break 2
					done
					test ${timeout} -eq 50 && ewarn "Waiting for devices to become available ..."
					timeout=$( expr ${timeout} - 1 )
					sleep 0.1
				done

				#
				# ... but we still need to give things time to settle
				#
				sleep 1
			done
		fi

		#
		# Before we start using the RAID array, we should really set the
		# IO scheduler to use on the constituent disks...
		#
		# This might better be done alongside hdparm, later in the boot
		# sequence.
		#
		local ios_name ios_module ios_queue
		case "${SCHEDULER}" in
			as|anticipatory)
				ios_name="Anticipatory"
				ios_module="as"
				ios_queue="anticipatory"
				;;
			cfq|fair)
				ios_name="Completely Fair"
				ios_module="cfq"
				ios_queue="cfq"
				;;
			*)
				ios_name="Completely Fair"
				ios_module="cfq"
				ios_queue="cfq"
				;;
		esac

		ebegin "Loading $ios_name I/O scheduler"
		modprobe "${ios_module}-iosched"
		eend $?

		set -- discard $( grep "^\s*DEVICE\s*" "${mdadm_conf}" )
		shift
		while [ -n "${1}" ]; do
			device="${1}"
			shift

			[ "${device}" = "DEVICE" ] && continue

			for node in /sys/block/"${device}"/queue/scheduler; do
				if [ -e "${node}" -a -n "$( grep -q "${ios_queue}" "${node}" >/dev/null 2>&1 )" ]; then
					ebegin "Setting I/O scheduler for device '${device}'"
					echo -n "$ios_queue" > "${node}"
					eend $? "Cannot install $ios_queue scheduler"
				fi
			done
		done

		if yesno ${ENABLENCQ}; then
			#
			# Additionally, try to enble NCQ for increased performance.
			# The libATA documentation says this should work...
			#
			set -- discard $( grep "^\s*DEVICE\s*" "${mdadm_conf}" )
			shift
			while [ -n "${1}" ]; do
				device="${1}"
				shift

				[ "${device}" = "DEVICE" ] && continue

				for node in /sys/block/"${device}"/device/queue_depth; do
					if [ -w "${node}" ]; then
						# Maximum depth should be 32, but 0xffffffff
						# is the same value returned when a device is
						# hot-unplugged, so that value is masked.
						ebegin "Setting maximum NCQ depth for device '${device}'"
						( echo -n "31" > "${node}" ) &>/dev/null
						eend $? "NCQ unavailable"
					fi
				done
			done
		fi
	fi

	ebegin "Starting up RAID devices"
	output=$(mdadm -As 2>&1)
	eend $? "${output}"

	local pat="/dev/md_d*"
	set -- ${pat}
	if [ "$*" != "${pat}" ] ; then
		ebegin "Creating RAID device partitions"
		blockdev "$@"
		eend $?
		# wait because vgscan runs next, and we want udev to fire
		sleep 1
	fi

	return 0
}

stop() {
	local output

	# XXX: Maybe drop this check ?
	[ ! -e /etc/mdadm/mdadm.conf ] && [ ! -e /etc/mdadm.conf ] && return 0

	ebegin "Shutting down RAID devices"
	output=$(mdadm -Ss 2>&1)
	eend $? "${output}"
}
