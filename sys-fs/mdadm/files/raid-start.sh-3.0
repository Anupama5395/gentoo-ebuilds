# /lib/rcscripts/addons/raid-start.sh:  Setup raid volumes at boot
# Copyright 1999-2010 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header: /var/cvsroot/gentoo-x86/sys-fs/mdadm/files/raid-start.sh-3.0,v 1.2 2010/06/03 02:03:40 vapier Exp $

#[ -f /proc/mdstat ] || exit 0
if [ ! -f /proc/mdstat ]; then
	ewarn "kernel lacks MD support"
	exit 0
fi

# We could make this dynamic, but eh
#[ -z ${MAJOR} ] && export MAJOR=$(awk '$2 == "md" { print $1 }' /proc/devices)
MAJOR=9

# Try to make sure the devices exist before we use them
create_devs() {
	local node dir minor
	for node in $@ ; do
		[ "${node#/dev}" != "${node}" ] && node="/dev/${node}"
		[ -e "${node}" ] && continue

		dir="${node%/*}"
		[ ! -d "${dir}" ] && mkdir -p "${dir}"

		minor="${node##*/}"
		mknod "${node}" b "${MAJOR}" "${minor##*md}" &> /dev/null
	done
}

# Start software raid with mdadm (new school)
start_md() {
	local mdadm_conf mdmod_conf mods devs mod dev timeout device node output ret
	mdadm_conf="/etc/mdadm/mdadm.conf"
	mdmod_conf="/etc/mdadm/mdmod.conf"
	[ -e /etc/mdadm.conf -a ! -e "$mdadm_conf" ] && mdadm_conf="/etc/mdadm.conf"
	[ -e /etc/mdmod.conf -a ! -e "$mdmod_conf" ] && mdmod_conf="/etc/mdmod.conf"
	if [ -x /sbin/mdadm -a -f "${mdadm_conf}" ]; then
		mods="$( awk '/^[[:space:]]*MODULE/ { print $2 }' "${mdadm_conf}" )"
		devs="$( awk '/^[[:space:]]*ARRAY/ { print $2 }' "${mdadm_conf}" )"
		if [ -n "${mods}" ]; then
			for mod in ${mods}; do
				mod="$( echo "${mod}" | sed 's/-/_/g' )"
				if [ -z "$( lsmod | grep "${mod}" )" ]; then
					ebegin "Loading RAID driver ${mod}"
					modprobe "${mod}"
					eend $? "Module load failed - storage array may be unavailable" || continue
				fi
				dev=$( egrep "^[[:space:]]*MODULE" "${mdmod_conf}" | \
					tr -s "[:space:]" | sed 's/^ //' | cut -d" " -f 3-
				)

				#
				# We can't wait until all devices are present, as some of the
				# physical disks they represent may be unplugged...
				#

				timeout=50

				while test ${timeout} -gt 0 ; do
					for device in ${dev}; do
						[ -e "${device}" ] && break 2
					done
					test ${timeout} -eq 50 && ewarn "Waiting for devices to become available ..."
					timeout=$( expr ${timeout} - 1 )
					sleep 0.1
				done

				#
				# ... but we still need to give things time to settle
				#

				sleep 1
			done
		fi

		#
		# Before we start using the RAID array, we should really set the
		# IO scheduler to use on the constituent disks...
		#
		# This might better be done alongside hdparm, later in the boot
		# sequence.
		#
#		local ios_name="Anticipatory"
#		local ios_module="as"
#		local ios_queue="anticipatory"
		#
		local ios_name="Completely Fair"
		local ios_module="cfq"
		local ios_queue="cfq"
		#
		ebegin "Loading $ios_name IO scheduler"
		modprobe "${ios_module}-iosched"
		ret=$?
		for node in /sys/block/sd?/queue/scheduler; do
			if [ -n "$( grep "${ios_queue}" "${node}" )" ]; then
				echo -n "$ios_queue" > "${node}"
			fi
		done
		eend ${ret} "Cannot install $ios_queue scheduler"
		#
		# Additionally, try to enble NCQ for increased performance.
		# The libATA documentation says this should work...
		#
		ebegin "Attempting to enable NCQ"
		ret=1
		for node in /sys/block/sd?/device/queue_depth; do
			if [ -w "${node}" ]; then
				# Maximum depth should be 32, but 0xffffffff
				# is the same value returned when a device is
				# hot-unplug(!), so that value is masked.
				( echo -n "31" > "${node}" ) &>/dev/null
				ret=$?
			fi
		done
		eend ${ret} "NCQ unavailable"

		if [ -n "${devs}" ]; then
			create_devs ${devs}
			ebegin "Starting up RAID devices"
			output=$( mdadm -As 2>&1 )
			ret=$?
			[ ${ret} -ne 0 ] && eerror "mdadm returned status ${ret}: '${output}'"
			eend ${ret} "Array assembly failed"
		fi
	fi
}

start_md

if [ -x /sbin/blockdev ] ; then
	partitioned_devs="$( ls /dev/md_d* 2>/dev/null )"
	if [ -n "${partitioned_devs}" ]; then
		ebegin "Creating RAID device partitions"
		/sbin/blockdev "${partitioned_devs}"
		eend 0
		# wait because vgscan runs next, and we want udev to fire
		sleep 1
	fi
fi

# vim:ts=4
